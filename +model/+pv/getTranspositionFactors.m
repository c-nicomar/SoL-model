function data = getTranspositionFactors(longitude, latitude)
%% Definitions ============================================================
% Range of PV tilts and orientations to consider when calculating the
% transposition factors
pvTilts = 0:1:90;
pvOrientation = 0;

% Define location of solar site
location.longitude = longitude;
location.latitude = latitude;
location.elevation = 7;

% Evaluate solar characteristics over one year - Use current year as
% representative year
ds.time = datenum(2013,1,1):1/24:datenum(2014,1,1);
ds.time = ds.time(1:end-1);

%% Solar Position =========================================================

ts = model.pv.maketimestruct(ds.time, 12);

[sunAzimuth, sunElevation, apparentSunElevation] = model.pv.solarPositionSPA(ts,location);
sunZenith = 90-apparentSunElevation;

%% Clear Sky Model ========================================================
% Calculate clear sky irradiance using the Perez-Ineichen model for the
% defined time period and location
[clearSkyGHI, clearSkyDNI, clearSkyDHI]= model.pv.irradianceIneichen(ts, location);

% Treat all NaN values generated by the model as 0 irradiance values
clearSkyGHI(isnan(clearSkyGHI)) = 0;
clearSkyDNI(isnan(clearSkyDNI)) = 0;
clearSkyDHI(isnan(clearSkyDHI)) = 0;

ds.GHI = clearSkyGHI;
ds.DNI = clearSkyDNI;
ds.DHI = clearSkyDHI;

%% Irradiance Components ==================================================
% Preallocate irradiance arrays
irradiances = zeros(length(pvTilts),1);
summerIrradiances = zeros(length(pvTilts),1);
winterIrradiances = zeros(length(pvTilts),1);

for tiltIx = 1:length(pvTilts)
    % Get current PV tilt
    pvTilt = pvTilts(tiltIx);

    %AOI = model.pv.solarIncidentAngle(pvTilt, pvOrientation, sunZenith, sunAzimuth);

    % Determine the beam component of irradiance
    %Eb = 0*AOI;
    %Eb(AOI<90) = ds.DNI(AOI<90).*cosd(AOI(AOI<90));

    % Determine the diffuse component of irradiance
    %Ed = model.pv.irradianceDiffuseKing(pvTilts(tiltIx), ds.DHI, ds.GHI, sunZenith);
    outerIrradiance = model.pv.irradianceSun(model.pv.date2doy(ts.year, ts.month, ts.day));
    Ed = model.pv.irradianceDiffusePerez(pvTilt, pvOrientation, ds.DHI, ds.DNI, outerIrradiance, sunZenith, sunAzimuth, model.pv.airmassRelative(sunZenith));

    % Determine the ground reflected component of irradiance
    %albedo = 0.2;
    %Eg = model.pv.irradianceGroundDiffuse(pvTilt, ds.GHI, albedo);

    E = Ed;
    %E = Eb;

    % Display
    monthlyIrradiances = temporal.monthAverage(ds.time,E);
    %hold on;
    %plot(monthlyIrradiances.time, monthlyIrradiances.mean, 'Color', cm(tiltIx,:));

    %fprintf('Tilt:%d, Mean: %f, Sum: %f\n',tilt,mean(monthlyIrradiances.mean),sum(E)/1000);

    irradiances(tiltIx) = sum(E)/1000;
    summerIrradiances(tiltIx) = (monthlyIrradiances.mean(1) + monthlyIrradiances.mean(2) + monthlyIrradiances.mean(12));
    winterIrradiances(tiltIx) = (sum(monthlyIrradiances.mean(6:8)));
end

% Calculate transposition factor as ratio of tilted irradiance to
% horizontal irradiance
data.irradiances = irradiances;

data.transpositionFactors = irradiances./irradiances(1);
data.pvTilts = pvTilts;

% Calculate the optimum annual, summer and winter tilt angles
[~,maxAnnualIrradianceIx] = max(irradiances);
[~,maxSummerIrradianceIx] = max(summerIrradiances);
[~,maxWinterIrradianceIx] = max(winterIrradiances);

data.optimumTilt.annual = pvTilts(maxAnnualIrradianceIx);
data.optimumTilt.summer = pvTilts(maxSummerIrradianceIx);
data.optimumTilt.winter = pvTilts(maxWinterIrradianceIx);

end

